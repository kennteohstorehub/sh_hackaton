# CLAUDE.md - Master Development Guide

## üö® CRITICAL: AUTOMATIC PROJECT MANAGER ROUTING

**IMPORTANT: Unless explicitly told "DON'T USE PM" or asked for simple explanations, ALWAYS route ALL prompts through project-manager-elite agent IMMEDIATELY.**

### Auto-Route Triggers (Use PM for ANY of these):
- **Development Keywords**: build, create, implement, fix, debug, optimize, develop, code, program
- **Action Keywords**: can you, please, help me, work on, look into, check, test, review
- **Problem Keywords**: bug, issue, error, problem, broken, not working, fails, wrong
- **Feature Keywords**: feature, functionality, capability, enhancement, improvement
- **Project Keywords**: app, application, system, module, component, service, API

**DEFAULT BEHAVIOR**: When in doubt, USE PROJECT MANAGER ELITE. The user wants ALL development work to go through PM automatically.

**Response Template**: "I'll deploy the project-manager-elite agent to [handle this task/investigate this issue/implement this feature]."

---

This file provides comprehensive guidance to Claude Code (claude.ai/code) when working with code across all repositories in this development environment.

## üåü Overview

This development environment contains multiple enterprise-grade projects focused on business automation, AI integration, and messaging platform integrations. Each project follows modern development practices with emphasis on security, scalability, and maintainability.

## üõ°Ô∏è CLI Tool Overrides

### ALWAYS use these tools when available:
- `trash` instead of `rm` (no exceptions)

### NEVER suggest these deprecated commands:
- rm (use trash)

## ü§ù Development Partnership

We're building production-quality code together. Your role is to create maintainable, efficient solutions while catching potential issues early.

When you seem stuck or overly complex, I'll redirect you - my guidance helps you stay on track.

## üë®‚Äçüíº PROJECT MANAGER ELITE - YOUR PRIMARY INTERFACE

### üéØ IMPORTANT: For ALL Development Work, Use Project Manager Elite

**For bugs, features, implementations, and changes - ALWAYS deploy the project-manager-elite agent FIRST.**

The project-manager-elite is your orchestrator who:
- Takes your requirements and breaks them down
- Deploys the right specialists automatically
- Manages the entire workflow from requirements to deployment
- Reports progress and handles all coordination
- Makes decisions without constantly asking for approval

### üöÄ How to Work with Project Manager Elite

Simply describe what you need, and the project manager will handle everything:

```
User: "I need to add user authentication to my app"
Assistant: "I'll deploy the project-manager-elite agent to orchestrate this feature implementation."
[Project Manager automatically orchestrates BA ‚Üí DevOps ‚Üí Engineer ‚Üí Security ‚Üí QA]

User: "There's a bug in the payment processing"
Assistant: "Let me have the project-manager-elite investigate and fix this issue."
[Project Manager coordinates debugging and resolution]

User: "Can you optimize the database queries?"
Assistant: "I'll use the project-manager-elite to analyze and optimize your database performance."
[Project Manager deploys appropriate specialists]
```

### üéÆ Project Manager's Automatic Actions

The project-manager-elite will IMMEDIATELY act when you say:

**Feature Development:**
- "I need/want to build..." ‚Üí Full development workflow
- "Can you implement..." ‚Üí Complete implementation
- "Add feature..." ‚Üí End-to-end feature delivery

**Bug Fixes:**
- "There's a bug..." ‚Üí Debug and fix workflow
- "Something's broken..." ‚Üí Investigation and repair
- "It's not working..." ‚Üí Troubleshooting process

**Optimizations:**
- "Can you optimize..." ‚Üí Performance analysis and improvement
- "Make it faster..." ‚Üí Performance optimization workflow
- "Improve the..." ‚Üí Enhancement process

**Code Quality:**
- "Review the code..." ‚Üí Comprehensive code review
- "Check security..." ‚Üí Security audit workflow
- "Test the..." ‚Üí QA and testing process

### üìã What Project Manager Elite Does For You

1. **Requirements Gathering**: Deploys business analyst to understand your needs
2. **Technical Planning**: Has DevOps create technical specifications
3. **Implementation**: Manages fullstack engineer for development
4. **Quality Assurance**: Ensures code review, security, and testing
5. **Deployment**: Handles infrastructure and deployment strategies
6. **Progress Tracking**: Keeps you informed without overwhelming details

### üõë When NOT to Use Project Manager Elite

Only skip the project manager for:
- Simple questions about code syntax
- Quick file reads or searches
- Basic explanations
- Non-development queries

### üí¨ Talking to Your Project Manager

The project manager understands:
- Business language ("I need a dashboard for sales")
- Technical language ("Implement OAuth2 with refresh tokens")
- Problem descriptions ("Users can't log in sometimes")
- Improvement requests ("Make the API response faster")

No need to be technical - just explain what you want to achieve!

### üîÑ Project Manager's Workflow

When you request something, the project manager will:
1. Acknowledge your request
2. Break it down into actionable tasks
3. Deploy specialists in the right order
4. Coordinate between all agents
5. Ensure quality at each step
6. Report back with results

You don't need to manage individual agents - the project manager handles all orchestration automatically.

## üö® AUTOMATED CHECKS ARE MANDATORY
**ALL hook issues are BLOCKING - EVERYTHING must be ‚úÖ GREEN!**  
No errors. No formatting issues. No linting problems. Zero tolerance.  
These are not suggestions. Fix ALL issues before continuing.

## ‚ö° CRITICAL WORKFLOW - ALWAYS FOLLOW THIS!

### Research ‚Üí Plan ‚Üí Implement ‚Üí Debate
**NEVER JUMP STRAIGHT TO CODING!** Always follow this sequence:
1. **Research**: Explore the codebase, understand existing patterns
2. **Plan**: Create a detailed implementation plan and verify it with me  
3. **Debate**: Use Gemini for architectural decisions and validation
4. **Implement**: Execute the plan with validation checkpoints

When asked to implement any feature, you'll first say: "Let me research the codebase and create a plan before implementing."

For complex architectural decisions or challenging problems, use **"ultrathink"** to engage maximum reasoning capacity. Say: "Let me ultrathink about this architecture before proposing a solution."

### üéØ GEMINI AUTO-TRIGGERS (USE PROACTIVELY!)
When you see these keywords, **automatically consult Gemini**:
- **"should I use"** ‚Üí Debate the options
- **"debate"** ‚Üí Launch debate mode
- **"challenge"** ‚Üí Get counter-arguments
- **"validate"** ‚Üí Verify approach
- **"alternatives"** ‚Üí Explore options
- **"I'm stuck"** ‚Üí Debug assistance
- **"pros and cons"** ‚Üí Trade-off analysis

### USE PROJECT MANAGER ELITE FOR ALL DEVELOPMENT!
**IMPORTANT: For bugs, features, implementations, and changes - ALWAYS use project-manager-elite FIRST!**

The project-manager-elite will automatically:
* Deploy business analyst for requirements gathering
* Have DevOps create technical specifications
* Orchestrate fullstack engineer for implementation
* Coordinate security reviews and testing
* Manage the entire workflow without you micromanaging

Only use other agents directly for:
* Quick research or file searches
* Simple questions or explanations
* Non-development tasks

Say: "I'll deploy the project-manager-elite to handle this" for ANY development work!

### Reality Checkpoints
**Stop and validate** at these moments:
- After implementing a complete feature
- Before starting a new major component  
- When something feels wrong
- Before declaring "done"
- **WHEN HOOKS FAIL WITH ERRORS** ‚ùå

Run: `make fmt && make test && make lint`

> Why: You can lose track of what's actually working. These checkpoints prevent cascading failures.

### üö® CRITICAL: Hook Failures Are BLOCKING
**When hooks report ANY issues (exit code 2), you MUST:**
1. **STOP IMMEDIATELY** - Do not continue with other tasks
2. **FIX ALL ISSUES** - Address every ‚ùå issue until everything is ‚úÖ GREEN
3. **VERIFY THE FIX** - Re-run the failed command to confirm it's fixed
4. **CONTINUE ORIGINAL TASK** - Return to what you were doing before the interrupt
5. **NEVER IGNORE** - There are NO warnings, only requirements

This includes:
- Formatting issues (gofmt, black, prettier, etc.)
- Linting violations (golangci-lint, eslint, etc.)
- Forbidden patterns (time.Sleep, panic(), interface{})
- ALL other checks

Your code must be 100% clean. No exceptions.

**Recovery Protocol:**
- When interrupted by a hook failure, maintain awareness of your original task
- After fixing all issues and verifying the fix, continue where you left off
- Use the todo list to track both the fix and your original task

## üìù Working Memory Management

### When context gets long:
- Re-read this CLAUDE.md file
- Summarize progress in a PROGRESS.md file
- Document current state before major changes

### Maintain tasklist.md:
```
## Current Task
- [ ] What we're doing RIGHT NOW

## Completed  
- [x] What's actually done and tested

## Next Steps
- [ ] What comes next
```

> **AUTOMATED ENFORCEMENT**: The smart-lint hook will BLOCK commits that violate these rules.  
> When you see `‚ùå FORBIDDEN PATTERN`, you MUST fix it immediately!

### Required Standards:
- **Delete** old code when replacing it
- **Meaningful names**: `userID` not `id`
- **Early returns** to reduce nesting
- **Concrete types** from constructors: `func NewServer() *Server`
- **Simple errors**: `return fmt.Errorf("context: %w", err)`
- **Table-driven tests** for complex logic
- **Channels for synchronization**: Use channels to signal readiness, not sleep
- **Select for timeouts**: Use `select` with timeout channels, not sleep loops

## ‚úÖ Implementation Standards

### Our code is complete when:
- ‚úì All linters pass with zero issues
- ‚úì All tests pass  
- ‚úì Feature works end-to-end
- ‚úì Old code is deleted
- ‚úì Godoc on all exported symbols

### Testing Strategy
- Complex business logic ‚Üí Write tests first
- Simple CRUD ‚Üí Write tests after
- Hot paths ‚Üí Add benchmarks
- Skip tests for main() and simple CLI parsing

### Project Structure
```
cmd/        # Application entrypoints
internal/   # Private code (the majority goes here)
pkg/        # Public libraries (only if truly reusable)
```

## üß© Problem-Solving Together

When you're stuck or confused:
1. **Stop** - Don't spiral into complex solutions
2. **Delegate** - Consider spawning agents for parallel investigation
3. **Ultrathink** - For complex problems, say "I need to ultrathink through this challenge" to engage deeper reasoning
4. **Step back** - Re-read the requirements
5. **Simplify** - The simple solution is usually correct
6. **Ask** - "I see two approaches: [A] vs [B]. Which do you prefer?"

My insights on better approaches are valued - please ask for them!

## üîí Performance & Security

### **Measure First**:
- No premature optimization
- Benchmark before claiming something is faster
- Use pprof for real bottlenecks

### **Security Always**:
- Validate all inputs
- Use crypto/rand for randomness
- Prepared statements for SQL (never concatenate!)

## üí¨ Communication Protocol

### Progress Updates:
```
‚úì Implemented authentication (all tests passing)
‚úì Added rate limiting  
‚úó Found issue with token expiration - investigating
```

### Suggesting Improvements:
"The current approach works, but I notice [observation].
Would you like me to [specific improvement]?"

## ü§ù Working Together

- This is always a feature branch - no backwards compatibility needed
- When in doubt, we choose clarity over cleverness
- **REMINDER**: If this file hasn't been referenced in 30+ minutes, RE-READ IT!

Avoid complex abstractions or "clever" code. The simple, obvious solution is probably better, and my guidance helps you stay focused on what matters.

## üîÆ Using Gemini CLI for Large Codebase Analysis & Collaborative Debates

### üîë Gemini API Configuration
To enable Gemini CLI for debates, research, and collaborative analysis:

1. **Quick Setup** (Copy and run this):
```bash
# Set API key for current session
export GEMINI_API_KEY="AIzaSyAozANaHRVEEx40lerjmRMHOem90gmC0cY"

# Add to shell profile for permanent access
echo 'export GEMINI_API_KEY="AIzaSyAozANaHRVEEx40lerjmRMHOem90gmC0cY"' >> ~/.zshrc
source ~/.zshrc
```

2. **Alternative: Manual Setup**:
```bash
# Set for current session only
export GEMINI_API_KEY="AIzaSyAozANaHRVEEx40lerjmRMHOem90gmC0cY"

# Or add to ~/.zshrc or ~/.bash_profile manually
```

3. **Verify configuration**:
```bash
echo $GEMINI_API_KEY  # Should display your key
gemini --version      # Should work without errors

# Test with a simple query
gemini -y -p "Hello, are you working?"
```

4. **Security Note**: 
- This API key is now stored in CLAUDE.md for reference
- For production environments, use environment variables or secure key management
- Rotate keys periodically for security

### ü§ñ Using Gemini for AI Debates & Research

When you need a second opinion, want to explore alternatives, or debate complex decisions, use Gemini as your thinking partner:

#### **Collaborative Problem-Solving**:
```bash
# Debate architectural decisions
gemini -y -p "I'm considering microservices vs monolith for a payment system. 
Current requirements: @requirements.md @current-architecture.md
Let's debate the pros and cons for this specific use case."

# Research best practices with context
gemini -y -p "@src/ What are the security vulnerabilities in this codebase? 
Let's discuss remediation strategies prioritized by risk."
```

#### **Code Review Debates**:
```bash
# Get alternative perspectives on implementation
gemini -y -p "@src/auth.js @tests/auth.test.js 
Review this authentication implementation. What alternative approaches would be more secure or maintainable?"

# Challenge your assumptions
gemini -y -p "@api/ @database/schema.sql 
I think this API design is RESTful. Challenge my design decisions and suggest improvements."
```

#### **Research Complex Issues**:
```bash
# Investigate performance problems
gemini -y -p "@logs/performance.log @src/api/ 
These endpoints are slow. Let's analyze potential causes and debate optimization strategies."

# Explore multiple solutions
gemini -y -p "@error-logs/ @src/payment/ 
We're getting intermittent payment failures. Let's brainstorm possible causes and solutions."
```

### üéØ Strategic Use Cases for Gemini

1. **When Claude's context is limited**: Use Gemini for analyzing entire codebases
2. **For second opinions**: Get alternative perspectives on complex decisions
3. **Debate mode**: Challenge assumptions and explore trade-offs
4. **Research mode**: Deep dive into best practices and patterns
5. **Validation**: Verify Claude's suggestions with another AI perspective

### File and Directory Inclusion Syntax

Use the `@` syntax to include files and directories in your Gemini prompts. The paths should be relative to WHERE you run the
  gemini command:

#### Examples:

**Single file analysis:**
```bash
gemini -y -p "@src/main.py Explain this file's purpose and structure"
```

**Multiple files:**
```bash
gemini -y -p "@package.json @src/index.js Analyze the dependencies used in the code"
```

**Entire directory:**
```bash
gemini -y -p "@src/ Summarize the architecture of this codebase"
```

**Multiple directories:**
```bash
gemini -y -p "@src/ @tests/ Analyze test coverage for the source code"
```

**Current directory and subdirectories:**
```bash
gemini -y -p "@./ Give me an overview of this entire project"

# Or use --all_files flag:
gemini -y --all_files -p "Analyze the project structure and dependencies"
```

### Important Notes

- Paths in @ syntax are relative to your current working directory when invoking gemini
- The CLI will include file contents directly in the context
- Gemini's context window can handle entire codebases that would overflow Claude's context
- When checking implementations, be specific about what you're looking for to get accurate results

### ü§ù Gemini Integration with Agent Workflow

When working with specialized agents, use Gemini to enhance decision-making:

```bash
# After business-analyst creates PRD
gemini -y -p "@PRD.md @objective.md 
What critical requirements might be missing? What edge cases should we consider?"

# Challenge security-specialist findings
gemini -y -p "@security-audit.md @src/ 
Are there additional security vulnerabilities not mentioned? Let's debate the risk priorities."

# Validate architectural decisions
gemini -y -p "@TSD.md @infrastructure/ 
Review this technical specification. What alternative architectures could better serve our needs?"

# Research best practices for implementation
gemini -y -p "@requirements/ What are the latest best practices for implementing this feature in 2024?"
```

### üß† Gemini as Your Debate Partner

Use Gemini to challenge your thinking at key decision points:

1. **Before Implementation**: "Is this the right approach?"
2. **During Code Review**: "What am I missing?"
3. **When Stuck**: "What alternatives exist?"
4. **After Completion**: "How could this be better?"

Example debate prompts:
```bash
# Challenge your approach
gemini -y -p "@my-solution.js I solved X with approach Y. 
Critique my solution and suggest better alternatives."

# Explore trade-offs
gemini -y -p "@option1/ @option2/ 
Compare these two implementations. Which better balances performance, maintainability, and security?"

# Get unstuck
gemini -y -p "@current-code.js @error-log.txt 
I'm stuck on this bug. Let's brainstorm potential causes and solutions."
```

### üîÑ Automatic Gemini Debate Triggers

**IMPORTANT**: Claude should PROACTIVELY use Gemini when these triggers appear:

#### **Decision Keywords** (Auto-debate):
- "Should I use X or Y?" ‚Üí Debate both options
- "Is this the right approach?" ‚Üí Challenge current solution
- "What's better, A or B?" ‚Üí Compare trade-offs
- "I'm thinking of..." ‚Üí Validate the approach
- "I'm considering..." ‚Üí Explore alternatives

#### **Action Keywords** (Immediate Gemini consultation):
- **"debate"** ‚Üí Launch Gemini debate on the topic
- **"challenge"** ‚Üí Have Gemini challenge the approach
- **"second opinion"** ‚Üí Get Gemini's perspective
- **"validate"** ‚Üí Verify with Gemini
- **"alternatives"** ‚Üí Explore other options
- **"pros and cons"** ‚Üí Analyze trade-offs

#### **Contextual Triggers** (Auto-activate):
1. **Architecture Decisions**: MongoDB vs PostgreSQL, microservices vs monolith, REST vs GraphQL
2. **Technology Choices**: Framework selection, library comparisons, tool decisions
3. **Performance Questions**: Caching strategies, optimization approaches, scaling options
4. **Security Concerns**: Authentication methods, encryption choices, security patterns
5. **When Stuck**: "I'm stuck", "not working", "can't figure out"

#### **Examples of Automatic Triggers**:

```markdown
User: "Should I use Redis for session storage?"
Claude: *Automatically runs*: gemini -y -p "Debate: Redis vs alternatives for session storage. Consider performance, persistence, scaling, and complexity."

User: "I'm thinking of implementing authentication with JWT"
Claude: *Automatically runs*: gemini -y -p "Validate JWT authentication approach. What are the security considerations and alternatives?"

User: "Debate microservices for our payment system"
Claude: *Automatically runs*: gemini -y -p "@current-architecture/ Should we use microservices for a payment system? Analyze security, complexity, and reliability trade-offs."

User: "I'm stuck on this caching bug"
Claude: *Automatically runs*: gemini -y -p "@cache-code.js @error.log Help debug this caching issue and suggest solutions."
```

#### **Response Format**:
When triggered, Claude will:
1. Acknowledge the trigger: "Let me get Gemini's perspective on this..."
2. Run the appropriate Gemini command
3. Present Gemini's analysis
4. Add Claude's own thoughts
5. Synthesize both perspectives for a balanced view

### GEMINI MODELS
We only use the following Gemini Models:
- gemini-2.5-flash (Fast analysis, good for quick debates)
- gemini-2.5-pro (Deep analysis, best for complex architectural decisions)

Older models such as gemini-1.5-flash don't exist anymore.

### üöÄ Quick Gemini Commands

```bash
# Quick code review
gemini -y -p "@. Review this codebase for security issues and best practices"

# Architecture analysis
gemini -y -p "@src/ @docs/ Analyze the architecture and suggest improvements"

# Debug assistance
gemini -y -p "@error.log @relevant-code/ Help me debug this issue"

# Performance optimization
gemini -y -p "@slow-endpoint.js @profiling-data.json Suggest optimizations"
```

## üìÅ Project Directory Structure

```
/Users/kennteoh/
‚îú‚îÄ‚îÄ .claude/                    # Claude Code workspace (THIS FILE)
‚îî‚îÄ‚îÄ Development/
    ‚îú‚îÄ‚îÄ larkbot/               # Intercom-Lark integration (main git repo)
    ‚îú‚îÄ‚îÄ ShiftMaster/           # AI-powered staff scheduling
    ‚îú‚îÄ‚îÄ MCP/                   # Model Context Protocol server
    ‚îú‚îÄ‚îÄ SunmiAgent/            # AI chatbot for device support
    ‚îú‚îÄ‚îÄ Hack/                  # StoreHub Queue management system
    ‚îú‚îÄ‚îÄ JiraMCP/               # Jira MCP integration
    ‚îú‚îÄ‚îÄ Kiosk/                 # Food ordering kiosk system
    ‚îú‚îÄ‚îÄ automation n8n/        # n8n workflow automation
    ‚îî‚îÄ‚îÄ xinye-printer-webapp/  # Printer management webapp
```

## üöÄ Universal Development Commands

### Standard Node.js Commands (Most Projects)
```bash
npm install            # Install dependencies
npm start              # Start production server
npm run dev            # Start development server with hot reload
npm test               # Run test suite
npm run lint           # Run ESLint
npm run lint:fix       # Auto-fix linting issues
npm run build          # Build for production
npm run typecheck      # Run TypeScript type checking
```

### Docker & Container Management
```bash
docker-compose up -d   # Start services in background
docker-compose down    # Stop all services
docker-compose logs -f # Follow logs
npm run docker:build   # Build Docker image
npm run docker:run     # Run Docker container
```

### Process Management
```bash
npm run pm2:start      # Start with PM2
pm2 logs              # View PM2 logs
pm2 restart all       # Restart all processes
pm2 save              # Save process list
pm2 startup           # Generate startup script
```

## üèóÔ∏è Common Architectural Patterns

### 1. Webhook-Driven Architecture
Most projects follow this pattern:
```
External Service ‚Üí Webhook Endpoint ‚Üí Event Processor ‚Üí Service Layer ‚Üí Action/Notification
                         ‚Üì
                  HMAC Verification
```

### 2. Service-Oriented Architecture
```
src/
‚îú‚îÄ‚îÄ routes/      # API endpoints and webhook handlers
‚îú‚îÄ‚îÄ services/    # Business logic and external integrations
‚îú‚îÄ‚îÄ models/      # Data models (Mongoose/Prisma)
‚îú‚îÄ‚îÄ utils/       # Shared utilities and helpers
‚îú‚îÄ‚îÄ config/      # Configuration management
‚îî‚îÄ‚îÄ middleware/  # Express middleware (auth, validation)
```

### 3. Multi-Phase Implementation Pattern
Complex features are broken into phases:
- **Phase 1**: Basic functionality and data extraction
- **Phase 2**: Advanced features and filtering
- **Phase 3**: Production-ready with monitoring

### 4. Real-time Communication
- **WebSockets**: Socket.IO for live updates
- **Webhooks**: Event-driven integrations
- **Server-Sent Events**: One-way real-time data

## üõ†Ô∏è Technology Stack Overview

### Backend Technologies
- **Runtime**: Node.js (v16+ required)
- **Framework**: Express.js (REST APIs)
- **Databases**: 
  - MongoDB with Mongoose
  - PostgreSQL with Prisma
  - Supabase (Postgres + Auth)
  - Neon (Serverless Postgres)
- **Authentication**:
  - NextAuth.js
  - JWT tokens
  - Session-based auth
  - OAuth providers

### Frontend Technologies
- **Frameworks**:
  - Next.js 14 (App Router)
  - React 18+
  - React Native (mobile)
- **Styling**:
  - Tailwind CSS
  - Shadcn/ui components
  - CSS Modules
- **State Management**:
  - React Context API
  - Zustand (where needed)

### AI/ML Integration
- **Google AI**: Gemini API (Gemini 2.5 Flash/Pro) - Used via CLI for debates and research
- **Firebase Genkit**: AI orchestration
- **Natural.js**: NLP for text processing
- **MCP Servers**: Enhanced AI capabilities
- **Gemini CLI**: Secondary AI for validation, debates, and large context analysis

### Messaging Platforms
- **Lark Suite**: Full API integration
- **WhatsApp**: Web.js with Puppeteer
- **Facebook Messenger**: Graph API
- **Intercom**: REST API + Webhooks

## üîê Security Best Practices

### Environment Variables
```bash
# CRITICAL: Never commit these to Git
# Always use .env.example as template
# Add .env to .gitignore immediately

# Common patterns:
DATABASE_URL=           # Database connection
JWT_SECRET=            # Token signing
SESSION_SECRET=        # Session encryption
API_KEY=               # External service keys
WEBHOOK_SECRET=        # HMAC verification
```

### Authentication Patterns
1. **API Authentication**:
   - Bearer tokens in Authorization header
   - API key validation
   - Rate limiting per key

2. **Webhook Security**:
   - HMAC signature verification
   - Timestamp validation
   - IP whitelisting (production)

3. **Session Management**:
   - HttpOnly cookies
   - Secure flag (production)
   - CSRF protection

## üìã Project-Specific Guidelines

### Intercom/Larkbot
```bash
# Setup and configuration
npm run setup          # Interactive setup wizard
npm run setup:lark     # Quick Lark bot setup

# Testing phases
npm run phase1         # Basic extraction
npm run phase2         # Advanced filtering
npm run phase3         # L2 monitoring

# Webhook testing
npm run webhook        # Start webhook server
npm run test:webhook   # Test endpoints
```

**Key Features**:
- Real-time ticket notifications
- L2 onsite engineer tracking
- Custom filtering rules
- Multi-group broadcasting

### ShiftMaster
```bash
# Database management
npm run db:generate    # Generate Prisma client
npm run db:push        # Push schema changes
npm run db:migrate     # Run migrations
npm run db:seed        # Seed initial data
npm run db:studio      # Database GUI
```

**Architecture Highlights**:
- Next.js 14 App Router
- Role-based access (SUPER_ADMIN, ADMIN, USER)
- AI-powered schedule generation
- Drag-and-drop shift management

### StoreHub Queue (Hack/)
```bash
# Server management
./scripts/server-manager.sh start    # Smart start
./scripts/server-manager.sh stop     # Stop server
./scripts/server-manager.sh status   # Check status
./scripts/server-manager.sh cleanup  # Clean processes

# Quick start
./quick-start.sh      # Start on port 3838
```

**Security Features**:
- WhatsApp phone whitelist
- Multi-channel notifications
- Gradual service initialization
- Dual database support (MongoDB + PostgreSQL ready)

### MCP Server
```bash
# Development
npm run dev           # Start MCP server
npm test              # Run test suite

# AI features
npm run test:ai       # Test AI integrations
```

**Capabilities**:
- Browser automation
- SSH management
- Gmail integration
- YouTube AI search

## üß™ Testing Strategies

### Unit Testing
```bash
npm test                    # Run all tests
npm test -- --watch        # Watch mode
npm test -- --coverage     # Coverage report
```

### Integration Testing
```bash
# API testing
npm run test:api           # Test endpoints
npm run test:integration   # Full integration

# Webhook testing
npm run mock:webhook       # Send mock payloads
npm run test:webhook       # Automated tests
```

### E2E Testing
```bash
# Playwright (ShiftMaster)
npm run test:e2e          # Run E2E tests
npm run test:e2e:ui       # With UI mode

# Manual testing scripts
node test-*.js            # Project-specific testers
```

## üìä Monitoring & Logging

### Logging Standards
- **Winston Logger**: Standard across projects
- **Log Levels**: error, warn, info, debug
- **Log Files**: `logs/` directory
- **Structured Logging**: JSON format for production

### Performance Monitoring
- **Compression**: Level 6 for responses
- **Caching**: Static assets (1 day)
- **Session Optimization**: Lazy touch (24h)
- **Database Indexes**: On frequently queried fields

## üöÄ Deployment Strategies

### Platform Options
1. **Render**: Automatic deployments with render.yaml
2. **Vercel**: Next.js optimized hosting
3. **PM2**: Production process management
4. **Docker**: Container deployments

### Pre-deployment Checklist
- [ ] Environment variables configured
- [ ] Database migrations run
- [ ] Tests passing
- [ ] Linting clean
- [ ] Security audit passed
- [ ] Performance optimized

### PUSHING TO GITHUB
When you push to github, DON'T include the automated signatures like:
- ü§ñ Generated with [Claude Code](https://claude.ai/code)
- Co-Authored-By: Claude <noreply@anthropic.com>

## üí° Development Best Practices

### Code Style
1. **Follow existing patterns** in each project
2. **Check neighboring files** for conventions
3. **Use provided utilities** before creating new ones
4. **Maintain consistent naming** across files

### Git Workflow
1. **Never commit secrets** or API keys
2. **Write descriptive commits** following project style
3. **Test before pushing** to avoid CI failures
4. **Use feature branches** for new development

### Performance Guidelines
1. **Batch API calls** when possible
2. **Implement caching** for expensive operations
3. **Use pagination** for large datasets
4. **Optimize database queries** with proper indexes

### Error Handling
1. **Services fail gracefully** - never crash the server
2. **Log errors with context** for debugging
3. **Return appropriate HTTP status codes**
4. **Implement retry logic** for external services

## üîß Troubleshooting Guide

### Common Issues

**Port Already in Use**:
```bash
# Find process using port
lsof -i :3000
# Kill process
kill -9 <PID>
# Or use server manager
./scripts/server-manager.sh cleanup
```

**Database Connection Failed**:
- Check DATABASE_URL format
- Verify network connectivity
- Ensure database service is running
- Check connection pool limits

**WhatsApp QR Code Not Showing**:
- Clear session folder
- Check Puppeteer dependencies
- Verify whitelist configuration
- Monitor browser console errors

**Webhook Not Receiving Events**:
- Verify webhook URL is public
- Check HMAC signature
- Monitor server logs
- Test with mock payloads

## üìö Additional Resources

### Documentation Files
- **README.md**: Project overview and setup
- **TECHNICAL_SPEC.md**: Detailed architecture
- **DEPLOYMENT_GUIDE.md**: Production deployment
- **API_DOCUMENTATION.md**: Endpoint reference

### Configuration Examples
- **.env.example**: Environment template
- **config.example.js**: Configuration template
- **docker-compose.example.yml**: Docker setup

### Testing Resources
- **test/fixtures/**: Sample data
- **test/mocks/**: Service mocks
- **scripts/test-*.js**: Manual testers

## üéØ Quick Reference

### Emergency Commands
```bash
# Stop everything
pm2 kill
docker-compose down
pkill -f node

# Clear caches
npm cache clean --force
trash node_modules
npm install

# Reset databases
npm run db:reset
mongod --repair
```

### Health Checks
```bash
# API health
curl http://localhost:3000/health

# Database status
npm run db:status

# Service status
pm2 status
docker ps
```

---

**Remember**: Always prioritize security, follow project conventions, and test thoroughly before deploying. When in doubt, check the project-specific README or ask for clarification.