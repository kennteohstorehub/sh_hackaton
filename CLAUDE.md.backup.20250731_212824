# CLAUDE.md - Master Development Guide

This file provides comprehensive guidance to Claude Code (claude.ai/code) when working with code across all repositories in this development environment.

## üåü Overview

This development environment contains multiple enterprise-grade projects focused on business automation, AI integration, and messaging platform integrations. Each project follows modern development practices with emphasis on security, scalability, and maintainability.

## üõ°Ô∏è CLI Tool Overrides

### ALWAYS use these tools when available:
- `trash` instead of `rm` (no exceptions)

### NEVER suggest these deprecated commands:
- rm (use trash)

## ü§ù Development Partnership

We're building production-quality code together. Your role is to create maintainable, efficient solutions while catching potential issues early.

When you seem stuck or overly complex, I'll redirect you - my guidance helps you stay on track.

## üéØ OPTIMIZED AGENT SELECTION (Token-Efficient)

Claude will automatically select the RIGHT agent with the RIGHT model for optimal speed and quality:

### üöÄ ESSENTIAL AGENTS (90% of tasks):
- **"build [feature]"** ‚Üí Fullstack architect (Sonnet 3.5) - Fast implementation
- **"debug this"** ‚Üí Senior debugger (Opus 3) - Deep reasoning for bugs
- **"optimize performance"** ‚Üí Performance engineer (Sonnet 3.5) - Systematic optimization

### üìã SITUATIONAL AGENTS (10% of tasks):
- **"coordinate [project]"** ‚Üí Project manager (Sonnet 3.5) - Only for 3+ component features
- **"design schema"** ‚Üí Database specialist (Opus 3) - Only for complex data models
- **"gather requirements"** ‚Üí Business analyst (Sonnet 3.5) - Only when requirements unclear

### ‚ùå REMOVED AGENTS (Use alternatives):
- ~~"review code"~~ ‚Üí Use fullstack-architect with review instructions
- ~~"fix security"~~ ‚Üí Run security audit before production only
- ~~"test this"~~ ‚Üí Use built-in testing in fullstack-architect
- ~~"create UI"~~ ‚Üí Use fullstack-architect with UI focus
- ~~"analyze architecture"~~ ‚Üí Use Gemini CLI directly

### üîç Global Debug Agent Available
The Claude Debug Agent is installed globally and available in any project:

**Quick Usage:**
```bash
claude-debug --quick          # Quick project diagnostics
claude-debug                  # Interactive debug mode
claude-debug --help          # Show all options
```

**Location**: `~/.claude/tools/debug-agent.js`
**Features**: Log analysis, performance monitoring, test debugging, real-time issue detection

### üí∞ Model Selection for Token Optimization:
**Sonnet 3.5** (Default for speed & cost):
- Code generation and implementation
- Routine tasks and CRUD operations
- Project coordination
- UI component creation

**Opus 3** (Only when needed):
- Complex debugging with subtle bugs
- Critical architectural decisions
- Database schema design with long-term impact
- When stuck after 2 failed attempts with Sonnet

### Complex Projects:
For multi-step projects, Claude will:
- Break down tasks into sequential steps
- Use ONE specialist at a time
- Complete each step before moving to the next
- **NEVER run multiple agents simultaneously**

### Simple Tasks (No Agent Needed):
- Quick file reads or searches
- Basic code explanations  
- Simple syntax questions
- Configuration help

## üö® AUTOMATED CHECKS ARE MANDATORY
**ALL hook issues are BLOCKING - EVERYTHING must be ‚úÖ GREEN!**  
No errors. No formatting issues. No linting problems. Zero tolerance.  
These are not suggestions. Fix ALL issues before continuing.

## ‚ö° CRITICAL WORKFLOW - ALWAYS FOLLOW THIS!

### Research ‚Üí Plan ‚Üí Implement ‚Üí Debate
**NEVER JUMP STRAIGHT TO CODING!** Always follow this sequence:
1. **Research**: Explore the codebase, understand existing patterns
2. **Plan**: Create a detailed implementation plan and verify it with me  
3. **Debate**: Use Gemini for architectural decisions and validation
4. **Implement**: Execute the plan with validation checkpoints

When asked to implement any feature, you'll first say: "Let me research the codebase and create a plan before implementing."

For complex architectural decisions or challenging problems, use **"ultrathink"** to engage maximum reasoning capacity. Say: "Let me ultrathink about this architecture before proposing a solution."

### üéØ GEMINI AUTO-TRIGGERS (USE PROACTIVELY!)
When you see these keywords, **automatically consult Gemini**:
- **"should I use"** ‚Üí Debate the options
- **"debate"** ‚Üí Launch debate mode
- **"challenge"** ‚Üí Get counter-arguments
- **"validate"** ‚Üí Verify approach
- **"alternatives"** ‚Üí Explore options
- **"I'm stuck"** ‚Üí Debug assistance
- **"pros and cons"** ‚Üí Trade-off analysis

### DIRECT AGENT WORKFLOW
**IMPORTANT: Claude will automatically select the right specialist for your task!**

**How it works:**
* Claude analyzes your request
* Deploys ONE specialist at a time
* Completes current agent work before starting next
* No concurrent agent execution

**CRITICAL RULES:**
* **ONLY ONE AGENT AT A TIME** - prevents token exhaustion and terminal hangs
* **SEQUENTIAL EXECUTION** - complete current work before next agent
* **NO PARALLEL AGENTS** - causes system instability and token waste

### Reality Checkpoints
**Stop and validate** at these moments:
- After implementing a complete feature
- Before starting a new major component  
- When something feels wrong
- Before declaring "done"
- **WHEN HOOKS FAIL WITH ERRORS** ‚ùå

Run: `make fmt && make test && make lint`

> Why: You can lose track of what's actually working. These checkpoints prevent cascading failures.

### üö® CRITICAL: Hook Failures Are BLOCKING
**When hooks report ANY issues (exit code 2), you MUST:**
1. **STOP IMMEDIATELY** - Do not continue with other tasks
2. **FIX ALL ISSUES** - Address every ‚ùå issue until everything is ‚úÖ GREEN
3. **VERIFY THE FIX** - Re-run the failed command to confirm it's fixed
4. **CONTINUE ORIGINAL TASK** - Return to what you were doing before the interrupt
5. **NEVER IGNORE** - There are NO warnings, only requirements

This includes:
- Formatting issues (gofmt, black, prettier, etc.)
- Linting violations (golangci-lint, eslint, etc.)
- Forbidden patterns (time.Sleep, panic(), interface{})
- ALL other checks

Your code must be 100% clean. No exceptions.

**Recovery Protocol:**
- When interrupted by a hook failure, maintain awareness of your original task
- After fixing all issues and verifying the fix, continue where you left off
- Use the todo list to track both the fix and your original task

## üìù Working Memory Management

### When context gets long:
- Re-read this CLAUDE.md file
- Summarize progress in a PROGRESS.md file
- Document current state before major changes

### Maintain tasklist.md:
```
## Current Task
- [ ] What we're doing RIGHT NOW

## Completed  
- [x] What's actually done and tested

## Next Steps
- [ ] What comes next
```

> **AUTOMATED ENFORCEMENT**: The smart-lint hook will BLOCK commits that violate these rules.  
> When you see `‚ùå FORBIDDEN PATTERN`, you MUST fix it immediately!

### Required Standards:
- **Delete** old code when replacing it
- **Meaningful names**: `userID` not `id`
- **Early returns** to reduce nesting
- **Concrete types** from constructors: `func NewServer() *Server`
- **Simple errors**: `return fmt.Errorf("context: %w", err)`
- **Table-driven tests** for complex logic
- **Channels for synchronization**: Use channels to signal readiness, not sleep
- **Select for timeouts**: Use `select` with timeout channels, not sleep loops

## ‚úÖ Implementation Standards

### Our code is complete when:
- ‚úì All linters pass with zero issues
- ‚úì All tests pass  
- ‚úì Feature works end-to-end
- ‚úì Old code is deleted
- ‚úì Godoc on all exported symbols

### Testing Strategy
- Complex business logic ‚Üí Write tests first
- Simple CRUD ‚Üí Write tests after
- Hot paths ‚Üí Add benchmarks
- Skip tests for main() and simple CLI parsing

### Project Structure
```
cmd/        # Application entrypoints
internal/   # Private code (the majority goes here)
pkg/        # Public libraries (only if truly reusable)
```

## üß© Problem-Solving Together

When you're stuck or confused:
1. **Stop** - Don't spiral into complex solutions
2. **Analyze** - Use ONE specialist agent for deep investigation
3. **Ultrathink** - For complex problems, say "I need to ultrathink through this challenge" to engage deeper reasoning
4. **Step back** - Re-read the requirements
5. **Simplify** - The simple solution is usually correct
6. **Ask** - "I see two approaches: [A] vs [B]. Which do you prefer?"

My insights on better approaches are valued - please ask for them!

## üîí Performance & Security

### **Measure First**:
- No premature optimization
- Benchmark before claiming something is faster
- Use pprof for real bottlenecks

### **Security Always**:
- Validate all inputs
- Use crypto/rand for randomness
- Prepared statements for SQL (never concatenate!)

## üí¨ Communication Protocol

### Progress Updates:
```
‚úì Implemented authentication (all tests passing)
‚úì Added rate limiting  
‚úó Found issue with token expiration - investigating
```

### Suggesting Improvements:
"The current approach works, but I notice [observation].
Would you like me to [specific improvement]?"

## ü§ù Working Together

- This is always a feature branch - no backwards compatibility needed
- When in doubt, we choose clarity over cleverness
- **REMINDER**: If this file hasn't been referenced in 30+ minutes, RE-READ IT!

Avoid complex abstractions or "clever" code. The simple, obvious solution is probably better, and my guidance helps you stay focused on what matters.

## üîÆ Using Gemini CLI for Large Codebase Analysis & Collaborative Debates

### üîë Gemini API Configuration
To enable Gemini CLI for debates, research, and collaborative analysis:

1. **Quick Setup** (Copy and run this):
```bash
# Set API key for current session
export GEMINI_API_KEY="AIzaSyAozANaHRVEEx40lerjmRMHOem90gmC0cY"

# Add to shell profile for permanent access
echo 'export GEMINI_API_KEY="AIzaSyAozANaHRVEEx40lerjmRMHOem90gmC0cY"' >> ~/.zshrc
source ~/.zshrc
```

2. **Alternative: Manual Setup**:
```bash
# Set for current session only
export GEMINI_API_KEY="AIzaSyAozANaHRVEEx40lerjmRMHOem90gmC0cY"

# Or add to ~/.zshrc or ~/.bash_profile manually
```

3. **Verify configuration**:
```bash
echo $GEMINI_API_KEY  # Should display your key
gemini --version      # Should work without errors

# Test with a simple query
gemini -y -p "Hello, are you working?"
```

4. **Security Note**: 
- This API key is now stored in CLAUDE.md for reference
- For production environments, use environment variables or secure key management
- Rotate keys periodically for security

### ü§ñ Using Gemini for AI Debates & Research

When you need a second opinion, want to explore alternatives, or debate complex decisions, use Gemini as your thinking partner:

#### **Collaborative Problem-Solving**:
```bash
# Debate architectural decisions
gemini -y -p "I'm considering microservices vs monolith for a payment system. 
Current requirements: @requirements.md @current-architecture.md
Let's debate the pros and cons for this specific use case."

# Research best practices with context
gemini -y -p "@src/ What are the security vulnerabilities in this codebase? 
Let's discuss remediation strategies prioritized by risk."
```

#### **Code Review Debates**:
```bash
# Get alternative perspectives on implementation
gemini -y -p "@src/auth.js @tests/auth.test.js 
Review this authentication implementation. What alternative approaches would be more secure or maintainable?"

# Challenge your assumptions
gemini -y -p "@api/ @database/schema.sql 
I think this API design is RESTful. Challenge my design decisions and suggest improvements."
```

#### **Research Complex Issues**:
```bash
# Investigate performance problems
gemini -y -p "@logs/performance.log @src/api/ 
These endpoints are slow. Let's analyze potential causes and debate optimization strategies."

# Explore multiple solutions
gemini -y -p "@error-logs/ @src/payment/ 
We're getting intermittent payment failures. Let's brainstorm possible causes and solutions."
```

### üéØ Strategic Use Cases for Gemini

1. **When Claude's context is limited**: Use Gemini for analyzing entire codebases
2. **For second opinions**: Get alternative perspectives on complex decisions
3. **Debate mode**: Challenge assumptions and explore trade-offs
4. **Research mode**: Deep dive into best practices and patterns
5. **Validation**: Verify Claude's suggestions with another AI perspective

### File and Directory Inclusion Syntax

Use the `@` syntax to include files and directories in your Gemini prompts. The paths should be relative to WHERE you run the
  gemini command:

#### Examples:

**Single file analysis:**
```bash
gemini -y -p "@src/main.py Explain this file's purpose and structure"
```

**Multiple files:**
```bash
gemini -y -p "@package.json @src/index.js Analyze the dependencies used in the code"
```

**Entire directory:**
```bash
gemini -y -p "@src/ Summarize the architecture of this codebase"
```

**Multiple directories:**
```bash
gemini -y -p "@src/ @tests/ Analyze test coverage for the source code"
```

**Current directory and subdirectories:**
```bash
gemini -y -p "@./ Give me an overview of this entire project"

# Or use --all_files flag:
gemini -y --all_files -p "Analyze the project structure and dependencies"
```

### Important Notes

- Paths in @ syntax are relative to your current working directory when invoking gemini
- The CLI will include file contents directly in the context
- Gemini's context window can handle entire codebases that would overflow Claude's context
- When checking implementations, be specific about what you're looking for to get accurate results

### ü§ù Gemini Integration with Agent Workflow

When working with specialized agents, use Gemini to enhance decision-making:

```bash
# After business-analyst creates PRD
gemini -y -p "@PRD.md @objective.md 
What critical requirements might be missing? What edge cases should we consider?"

# Challenge security-specialist findings
gemini -y -p "@security-audit.md @src/ 
Are there additional security vulnerabilities not mentioned? Let's debate the risk priorities."

# Validate architectural decisions
gemini -y -p "@TSD.md @infrastructure/ 
Review this technical specification. What alternative architectures could better serve our needs?"

# Research best practices for implementation
gemini -y -p "@requirements/ What are the latest best practices for implementing this feature in 2024?"
```

### üß† Gemini as Your Debate Partner

Use Gemini to challenge your thinking at key decision points:

1. **Before Implementation**: "Is this the right approach?"
2. **During Code Review**: "What am I missing?"
3. **When Stuck**: "What alternatives exist?"
4. **After Completion**: "How could this be better?"

Example debate prompts:
```bash
# Challenge your approach
gemini -y -p "@my-solution.js I solved X with approach Y. 
Critique my solution and suggest better alternatives."

# Explore trade-offs
gemini -y -p "@option1/ @option2/ 
Compare these two implementations. Which better balances performance, maintainability, and security?"

# Get unstuck
gemini -y -p "@current-code.js @error-log.txt 
I'm stuck on this bug. Let's brainstorm potential causes and solutions."
```

### üîÑ Automatic Gemini Debate Triggers

**IMPORTANT**: Claude should PROACTIVELY use Gemini when these triggers appear:

#### **Decision Keywords** (Auto-debate):
- "Should I use X or Y?" ‚Üí Debate both options
- "Is this the right approach?" ‚Üí Challenge current solution
- "What's better, A or B?" ‚Üí Compare trade-offs
- "I'm thinking of..." ‚Üí Validate the approach
- "I'm considering..." ‚Üí Explore alternatives

#### **Action Keywords** (Immediate Gemini consultation):
- **"debate"** ‚Üí Launch Gemini debate on the topic
- **"challenge"** ‚Üí Have Gemini challenge the approach
- **"second opinion"** ‚Üí Get Gemini's perspective
- **"validate"** ‚Üí Verify with Gemini
- **"alternatives"** ‚Üí Explore other options
- **"pros and cons"** ‚Üí Analyze trade-offs

#### **Contextual Triggers** (Auto-activate):
1. **Architecture Decisions**: MongoDB vs PostgreSQL, microservices vs monolith, REST vs GraphQL
2. **Technology Choices**: Framework selection, library comparisons, tool decisions
3. **Performance Questions**: Caching strategies, optimization approaches, scaling options
4. **Security Concerns**: Authentication methods, encryption choices, security patterns
5. **When Stuck**: "I'm stuck", "not working", "can't figure out"

#### **Examples of Automatic Triggers**:

```markdown
User: "Should I use Redis for session storage?"
Claude: *Automatically runs*: gemini -y -p "Debate: Redis vs alternatives for session storage. Consider performance, persistence, scaling, and complexity."

User: "I'm thinking of implementing authentication with JWT"
Claude: *Automatically runs*: gemini -y -p "Validate JWT authentication approach. What are the security considerations and alternatives?"

User: "Debate microservices for our payment system"
Claude: *Automatically runs*: gemini -y -p "@current-architecture/ Should we use microservices for a payment system? Analyze security, complexity, and reliability trade-offs."

User: "I'm stuck on this caching bug"
Claude: *Automatically runs*: gemini -y -p "@cache-code.js @error.log Help debug this caching issue and suggest solutions."
```

#### **Response Format**:
When triggered, Claude will:
1. Acknowledge the trigger: "Let me get Gemini's perspective on this..."
2. Run the appropriate Gemini command
3. Present Gemini's analysis
4. Add Claude's own thoughts
5. Synthesize both perspectives for a balanced view

### GEMINI MODELS
We only use the following Gemini Models:
- gemini-2.5-flash (Fast analysis, good for quick debates)
- gemini-2.5-pro (Deep analysis, best for complex architectural decisions)

Older models such as gemini-1.5-flash don't exist anymore.

### üöÄ Quick Gemini Commands

```bash
# Quick code review
gemini -y -p "@. Review this codebase for security issues and best practices"

# Architecture analysis
gemini -y -p "@src/ @docs/ Analyze the architecture and suggest improvements"

# Debug assistance
gemini -y -p "@error.log @relevant-code/ Help me debug this issue"

# Performance optimization
gemini -y -p "@slow-endpoint.js @profiling-data.json Suggest optimizations"
```

## üìÅ Project Directory Structure

```
/Users/kennteoh/
‚îú‚îÄ‚îÄ .claude/                    # Claude Code workspace (THIS FILE)
‚îî‚îÄ‚îÄ Development/
    ‚îú‚îÄ‚îÄ larkbot/               # Intercom-Lark integration (main git repo)
    ‚îú‚îÄ‚îÄ ShiftMaster/           # AI-powered staff scheduling
    ‚îú‚îÄ‚îÄ MCP/                   # Model Context Protocol server
    ‚îú‚îÄ‚îÄ SunmiAgent/            # AI chatbot for device support
    ‚îú‚îÄ‚îÄ Hack/                  # StoreHub Queue management system
    ‚îú‚îÄ‚îÄ JiraMCP/               # Jira MCP integration
    ‚îú‚îÄ‚îÄ Kiosk/                 # Food ordering kiosk system
    ‚îú‚îÄ‚îÄ automation n8n/        # n8n workflow automation
    ‚îî‚îÄ‚îÄ xinye-printer-webapp/  # Printer management webapp
```

## üöÄ Universal Development Commands

### Standard Node.js Commands (Most Projects)
```bash
npm install            # Install dependencies
npm start              # Start production server
npm run dev            # Start development server with hot reload
npm test               # Run test suite
npm run lint           # Run ESLint
npm run lint:fix       # Auto-fix linting issues
npm run build          # Build for production
npm run typecheck      # Run TypeScript type checking
```

### Docker & Container Management
```bash
docker-compose up -d   # Start services in background
docker-compose down    # Stop all services
docker-compose logs -f # Follow logs
npm run docker:build   # Build Docker image
npm run docker:run     # Run Docker container
```

### Process Management
```bash
npm run pm2:start      # Start with PM2
pm2 logs              # View PM2 logs
pm2 restart all       # Restart all processes
pm2 save              # Save process list
pm2 startup           # Generate startup script
```

## üèóÔ∏è Common Architectural Patterns

### 1. Webhook-Driven Architecture
Most projects follow this pattern:
```
External Service ‚Üí Webhook Endpoint ‚Üí Event Processor ‚Üí Service Layer ‚Üí Action/Notification
                         ‚Üì
                  HMAC Verification
```

### 2. Service-Oriented Architecture
```
src/
‚îú‚îÄ‚îÄ routes/      # API endpoints and webhook handlers
‚îú‚îÄ‚îÄ services/    # Business logic and external integrations
‚îú‚îÄ‚îÄ models/      # Data models (Mongoose/Prisma)
‚îú‚îÄ‚îÄ utils/       # Shared utilities and helpers
‚îú‚îÄ‚îÄ config/      # Configuration management
‚îî‚îÄ‚îÄ middleware/  # Express middleware (auth, validation)
```

### 3. Multi-Phase Implementation Pattern
Complex features are broken into phases:
- **Phase 1**: Basic functionality and data extraction
- **Phase 2**: Advanced features and filtering
- **Phase 3**: Production-ready with monitoring

### 4. Real-time Communication
- **WebSockets**: Socket.IO for live updates
- **Webhooks**: Event-driven integrations
- **Server-Sent Events**: One-way real-time data

## üõ†Ô∏è Technology Stack Overview

### Backend Technologies
- **Runtime**: Node.js (v16+ required)
- **Framework**: Express.js (REST APIs)
- **Databases**: 
  - MongoDB with Mongoose
  - PostgreSQL with Prisma
  - Supabase (Postgres + Auth)
  - Neon (Serverless Postgres)
- **Authentication**:
  - NextAuth.js
  - JWT tokens
  - Session-based auth
  - OAuth providers

### Frontend Technologies
- **Frameworks**:
  - Next.js 14 (App Router)
  - React 18+
  - React Native (mobile)
- **Styling**:
  - Tailwind CSS
  - Shadcn/ui components
  - CSS Modules
- **State Management**:
  - React Context API
  - Zustand (where needed)

### AI/ML Integration
- **Google AI**: Gemini API (Gemini 2.5 Flash/Pro) - Used via CLI for debates and research
- **Firebase Genkit**: AI orchestration
- **Natural.js**: NLP for text processing
- **MCP Servers**: Enhanced AI capabilities
- **Gemini CLI**: Secondary AI for validation, debates, and large context analysis

### Messaging Platforms
- **Lark Suite**: Full API integration
- **WhatsApp**: Web.js with Puppeteer
- **Facebook Messenger**: Graph API
- **Intercom**: REST API + Webhooks

## üîê Security Best Practices

### Environment Variables
```bash
# CRITICAL: Never commit these to Git
# Always use .env.example as template
# Add .env to .gitignore immediately

# Common patterns:
DATABASE_URL=           # Database connection
JWT_SECRET=            # Token signing
SESSION_SECRET=        # Session encryption
API_KEY=               # External service keys
WEBHOOK_SECRET=        # HMAC verification
```

### Authentication Patterns
1. **API Authentication**:
   - Bearer tokens in Authorization header
   - API key validation
   - Rate limiting per key

2. **Webhook Security**:
   - HMAC signature verification
   - Timestamp validation
   - IP whitelisting (production)

3. **Session Management**:
   - HttpOnly cookies
   - Secure flag (production)
   - CSRF protection

## üìã Project-Specific Guidelines

### Intercom/Larkbot
```bash
# Setup and configuration
npm run setup          # Interactive setup wizard
npm run setup:lark     # Quick Lark bot setup

# Testing phases
npm run phase1         # Basic extraction
npm run phase2         # Advanced filtering
npm run phase3         # L2 monitoring

# Webhook testing
npm run webhook        # Start webhook server
npm run test:webhook   # Test endpoints
```

**Key Features**:
- Real-time ticket notifications
- L2 onsite engineer tracking
- Custom filtering rules
- Multi-group broadcasting

### ShiftMaster
```bash
# Database management
npm run db:generate    # Generate Prisma client
npm run db:push        # Push schema changes
npm run db:migrate     # Run migrations
npm run db:seed        # Seed initial data
npm run db:studio      # Database GUI
```

**Architecture Highlights**:
- Next.js 14 App Router
- Role-based access (SUPER_ADMIN, ADMIN, USER)
- AI-powered schedule generation
- Drag-and-drop shift management

### StoreHub Queue (Hack/)
```bash
# Server management
./scripts/server-manager.sh start    # Smart start
./scripts/server-manager.sh stop     # Stop server
./scripts/server-manager.sh status   # Check status
./scripts/server-manager.sh cleanup  # Clean processes

# Quick start
./quick-start.sh      # Start on port 3838
```

**Security Features**:
- WhatsApp phone whitelist
- Multi-channel notifications
- Gradual service initialization
- Dual database support (MongoDB + PostgreSQL ready)

### MCP Server
```bash
# Development
npm run dev           # Start MCP server
npm test              # Run test suite

# AI features
npm run test:ai       # Test AI integrations
```

**Capabilities**:
- Browser automation
- SSH management
- Gmail integration
- YouTube AI search

## üß™ Testing Strategies

### Unit Testing
```bash
npm test                    # Run all tests
npm test -- --watch        # Watch mode
npm test -- --coverage     # Coverage report
```

### Integration Testing
```bash
# API testing
npm run test:api           # Test endpoints
npm run test:integration   # Full integration

# Webhook testing
npm run mock:webhook       # Send mock payloads
npm run test:webhook       # Automated tests
```

### E2E Testing
```bash
# Playwright (ShiftMaster)
npm run test:e2e          # Run E2E tests
npm run test:e2e:ui       # With UI mode

# Manual testing scripts
node test-*.js            # Project-specific testers
```

## üìä Monitoring & Logging

### Logging Standards
- **Winston Logger**: Standard across projects
- **Log Levels**: error, warn, info, debug
- **Log Files**: `logs/` directory
- **Structured Logging**: JSON format for production

### Performance Monitoring
- **Compression**: Level 6 for responses
- **Caching**: Static assets (1 day)
- **Session Optimization**: Lazy touch (24h)
- **Database Indexes**: On frequently queried fields

## üöÄ Deployment Strategies

### Platform Options
1. **Render**: Automatic deployments with render.yaml
2. **Vercel**: Next.js optimized hosting
3. **PM2**: Production process management
4. **Docker**: Container deployments

### Pre-deployment Checklist
- [ ] Environment variables configured
- [ ] Database migrations run
- [ ] Tests passing
- [ ] Linting clean
- [ ] Security audit passed
- [ ] Performance optimized

### PUSHING TO GITHUB
When you push to github, DON'T include the automated signatures like:
- ü§ñ Generated with [Claude Code](https://claude.ai/code)
- Co-Authored-By: Claude <noreply@anthropic.com>

## üí° Development Best Practices

### Code Style
1. **Follow existing patterns** in each project
2. **Check neighboring files** for conventions
3. **Use provided utilities** before creating new ones
4. **Maintain consistent naming** across files

### Git Workflow
1. **Never commit secrets** or API keys
2. **Write descriptive commits** following project style
3. **Test before pushing** to avoid CI failures
4. **Use feature branches** for new development

### Performance Guidelines
1. **Batch API calls** when possible
2. **Implement caching** for expensive operations
3. **Use pagination** for large datasets
4. **Optimize database queries** with proper indexes

### Error Handling
1. **Services fail gracefully** - never crash the server
2. **Log errors with context** for debugging
3. **Return appropriate HTTP status codes**
4. **Implement retry logic** for external services

## üîß Troubleshooting Guide

### Common Issues

**Port Already in Use**:
```bash
# Find process using port
lsof -i :3000
# Kill process
kill -9 <PID>
# Or use server manager
./scripts/server-manager.sh cleanup
```

**Database Connection Failed**:
- Check DATABASE_URL format
- Verify network connectivity
- Ensure database service is running
- Check connection pool limits

**WhatsApp QR Code Not Showing**:
- Clear session folder
- Check Puppeteer dependencies
- Verify whitelist configuration
- Monitor browser console errors

**Webhook Not Receiving Events**:
- Verify webhook URL is public
- Check HMAC signature
- Monitor server logs
- Test with mock payloads

## üìö Additional Resources

### Documentation Files
- **README.md**: Project overview and setup
- **TECHNICAL_SPEC.md**: Detailed architecture
- **DEPLOYMENT_GUIDE.md**: Production deployment
- **API_DOCUMENTATION.md**: Endpoint reference

### Configuration Examples
- **.env.example**: Environment template
- **config.example.js**: Configuration template
- **docker-compose.example.yml**: Docker setup

### Testing Resources
- **test/fixtures/**: Sample data
- **test/mocks/**: Service mocks
- **scripts/test-*.js**: Manual testers

## üéØ Quick Reference

### Emergency Commands
```bash
# Stop everything
pm2 kill
docker-compose down
pkill -f node

# Clear caches
npm cache clean --force
trash node_modules
npm install

# Reset databases
npm run db:reset
mongod --repair
```

### Health Checks
```bash
# API health
curl http://localhost:3000/health

# Database status
npm run db:status

# Service status
pm2 status
docker ps
```

---

**Remember**: Always prioritize security, follow project conventions, and test thoroughly before deploying. When in doubt, check the project-specific README or ask for clarification.
